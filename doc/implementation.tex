\section{FEM Code Implementation}
contains development of the program code with focus on the assembly of the system and its solving, the process of parallelization %TODO
 
 
 
 \subsection{Introduction to libMesh}
 The libMesh finite element library was stared as part of the Ph.D. work of Benjamin Kirk \cite{kirk2007adaptive}. It is a tool for numerical simulation of partial differential equations on serial and parallel platforms and uses the finite element method. Major goals are to provide data structures and algorithms for applications that need implicit numerical methods, parallel computing, adaptive mesh refinement techniques, or, a combination of them. Further, it simplifies many programming details for the user, such as: Reading the mesh from file, initialize data structures, solving the dicretized system, and, writing out the results \cite{kirk2013case}.
 
 LibMesh allows discretization of one, two and three dimensional problems using several geometric element types, including: Edges, quadrilaterals, triangles, tetrahedra, hexahedra, pyramids, prisms and some infinite elements of quadrilaterals or hexahedra. Finite elements include traditional first and second order Lagrange, as well as arbitrary order hierarchical bases, and N\'{e}d\'{e}lec elements of first type.
 
 Mesh partitioning is available in libMesh through interfaces to several external packages, but also some internal partitioning algorithms are provided: Linear and centroid partitioner as examples of internal algorithms, Metis and ParMetis \cite{karypis1998fast} as examples for external partitioner. In addition to these two, libMesh includes interfaces to solver libraries such as PETSc \cite{petsc2015url} and LASPack \cite{laspack2015url}. Thus, libMesh provides several linear equation solvers such as GMRES, CG, Bi-CGSTAB, QMR, and preconditioners like Jacobi, incomplete LU factorization and incomplete Cholesky factorization. The choice of an appropriate solver and preconditioner is made by the user at runtime.
 
 A wide variety of mesh formats are supported by libMesh to facilitate use of complex geometries. The following is an incomplete list of supported input and output formats: Nemesis, TetGen, I-deas Universal UNV, AVS's ASCII UCD, Visualization Toolkit VTK, libMesh formats XDR/XDA, ExodusII, GMSH, LANL's General Mesh Viewer GMV, GnuPlot (only output), Matlab (only input) \cite{kirk2013case}.
 
 An example program using the libMesh library would look like listing \ref{lst:example-libmesh}.
 \begin{lstlisting}[caption=Example libMesh program,label=lst:example-libmesh]
#include "libmesh/libmesh.h"
#include "libmesh/additional_libmesh_components"

using namespace libMesh;

void assemble_something(EquationSystems& es, const std::string& system_name);

int main (int argc, char** argv)
{
	LibMeshInit (int argc, char** argv);
	
	Mesh mesh( init.comm() );
	
	// mesh generation via MeshTools::Generation::build_... or mesh import from file via mesh.read(std::string filename)
	
	EquationSystems es(mesh);
	
	LinearImplicitSystem& system = es.add_system<LinearImplicitSystem> ("example system");
	
	system.add_variable ("a", FIRST);
	system.add_variable ("b", SECOND, LAGRANGE);
	
	system.attach_assemble_function (assemble_something);

	es.init();
	
	system.solve();
	
	VTKIO (mesh).write_equation_systems ("out.pvtu", es);
	
	return 0;
}
 \end{lstlisting}
 In fact, this is the base construction of nearly every libMesh program. It starts with including libMesh components that are needed by the program, e.g. \textit{mesh.h, equation\_systems.h, fe.h}. Then, the library needs to be initialized (line 10). This is necessary because it may depend on a number of other external libraries like MPI and PETSc that require initialization before use. On the other hand, if the \texttt{\textbf{LibMeshInit}} object goes out of scope, the other libraries are finalized automatically by libMesh. Next, a mesh is created (lines 12-14) on the default MPI communicator (even if the program is executed single-threaded). The mesh can either be read from file or created by internal mesh generation tools. In line 16 an equation systems object is created. It can contain multiple different systems. Here, only one linear implicit system is added to the object (line 16). Each system can contain multiple variables of different approximation orders (see lines 20/21). Many systems require a user-defined function that will assemble the (linear) system (lines 6 and 23). Now, the data structures for equation system must be initialized which is done in line 25. The solving of the systems is done in line 27 of the code. This one line of code calls the assemble function defined earlier and invokes the default numerical solver. If the external library PETSc is installed, the solver can be controlled from the command line by the user. After solving the system, the solution can be written to file; here, for example, the results are written to a VTK-formatted plot file (line 29).
 
 \subsection{Implementation Details}
 details about the implementation with the libmesh FEM framework \\%TODO
 - short overview: stand-alone-version: gets input parameters from user and mesh file and produces results stored in output file

 %\begin{lstlisting}[caption=Example libMesh program,label=lst1]
 %\end{lstlisting}
 
  \subsubsection{Initialization}\label{sec:Impl_Detail_Init}
  The program expects a few parameters set by the user through the command line at start. The ordering of these parameters are not relevant; some are optional. Here is a complete list of all parameters that can be set in the command line:
  \begin{itemize}
  	\item \textbf{-nu}: The Poisson's ratio $\nu$ is required by the material matrices. A value in the range $0.0 < \nu \leq 0.5$ is recommended for most scenarios.
  	\item \textbf{-e}: The elastic modulus or Young's modulus $E$ is also required by the material matrices. Here, a value $E \gg 0$ is recommended.
  	\item \textbf{-t}: The thickness $t$ of the mesh. It is used at both, the material matrices and the strain-displacement matrices and thus a required parameter to be set by the user.
  	\item \textbf{-d}: If set to "`1"' additional messages regarding transformation matrix entries, strain-displacement matrices, force load vectors and other internal mathematic structures are put out on the console. This parameter is optional, as it only gives the user more information in case of finding error. Since it slows down the calculation, it should only be set if needed. To turn off the messages, simply ignore the parameter or set it to 0.
  	\item \textbf{-mesh}: The file name of the mesh file to be imported. A required parameter, because no default mesh is coded into the program to be used. The relative path to the file (+ extension) must be specified. Allowed file formats are: libMesh format \textit{xda} (ASCII) and \textit{xdr} (binary) as well as GMSH format \textit{msh}. For more details, see section \ref{sec:Impl_Detail_MeshFileImport}.
  	\item \textbf{-out}: The relative path and filename (\textit{without} extension) for the output of the resulting mesh. This parameter is optional. If not set, no output file will be created. The path to the filename must exist, otherwise no file can be created.
  \end{itemize}
  
  If the external library PETSc is installed and libMesh is configured to be able to use it, the user can set additional optional parameters \cite{petsc-user-ref}. In fact, if one uses PETSc, it will look though all command line arguments by itself to find those it can process. The following list is therefore limited to parameters that directly coincide with the need of this program. For more PETSc command line argument see \cite{petsc-user-ref}.
  \begin{itemize}
  	\item \textbf{-ksp\_type}: Specifies the Krylov subspace method. Options are: \texttt{richardson}, \texttt{chebyshev}, \texttt{cg}, \texttt{gmres}, \texttt{tcqmr}, \texttt{bcgs}, \texttt{cgs}, \texttt{tfqmr}, \texttt{cr}, \texttt{lsqr}, \texttt{bicg}, \texttt{preonly}.
  	\item \textbf{-pc\_type}: To employ a particular preconditioning method used with the Krylov space method, the user can select one using this command line argument. Options are: \texttt{none}, \texttt{jacobi}, \texttt{bjacobi}, \texttt{sor}, \texttt{eisenstat}, \texttt{icc}, \texttt{ilu}, \texttt{asm}, \texttt{gasm}, \texttt{gamg}, \texttt{bddc}, \texttt{ksp}, \texttt{composite}, \texttt{lu}, \texttt{cholesky}, \texttt{shell}. 
  \end{itemize}
   
   
   
  \subsubsection{Mesh file import}\label{sec:Impl_Detail_MeshFileImport}
   The mesh geometry needs to be defined in a mesh file. LibMesh can import meshes from many different formats, including its own libMesh formats XDA and XDA, the first one stored in readable ASCII format, the latter one stored as binary code. Another one is the GMSH format \textit{msh}. There are other formats libMesh can import, but only the three mentioned formats are currently supported by the thesis' program.
   A mesh file must provide the following information in order to be usable be the implementation:
   \begin{itemize}
   	\item A list of vertices. Every vertex must be specified with its $xyz$-coordinates defined in the global coordinate system.
   	\item A list of elements the mesh consists out of. The elements are normally defined by their type, for example three node triangle or four node quadrilateral, and a list of vertex identifiers representing the nodes of the element.
   	\item A list of boundary conditions. The program provides two different types of boundary conditions. The type is to be specified in form of identifiers on element's nodes or edges. In the latter case the boundary condition is used on both nodes defining the edge.
   \end{itemize}
   Listing \ref{lst:xda} shows a short example of a mesh defined in the xda-format. It represents the unit square with its center at the global origin, composed of two three node triangles. It has different boundary conditions on the bottom and top edge.
\begin{lstlisting}[caption=Example xda mesh file,label=lst:xda,language=bash,keepspaces=true]
libMesh-0.7.0+
2       # number of elements
4       # number of nodes
.       # boundary condition specification file
n/a     # subdomain id specification file
n/a     # processor id specification file
n/a     # p-level specification file
2       # n_elem at level 0, [ type (n0 ... nN-1) ]
3 0 1 2          # 3 -> triangle with 3 nodes, 0 1 2 -> vertices 0, 1 and 2
3 1 3 2          #                             1 3 2 -> vertices 1, 3 and 2
-1.0 -1.0  0.0   # x y z coordinates of vertex 0
 1.0 -1.0  0.0   #                      vertex 1
-1.0  1.0  0.0   #                      vertex 2
 1.0  1.0  0.0   #                      vertex 3
2                # number of boundary conditions
0 0 1            # 0 -> element 0, 0 -> edge 0 (between vertex 0 and 1), bc-type 1
1 1 0            # 1 -> element 1, 1 -> edge 1 (between vertex 3 and 2), bc-type 0
\end{lstlisting}
   
   The program features two different types of boundary conditions whose identifier must be set in the mesh file:
   \begin{itemize}
   	\item Clamped boundary has the type "`\textbf{0}"'. %todo mathematische erklärung und prüfen ob wirklich 0 oder doch eher 1
   	\item Simply supported boundary has type "`\textbf{1}"'. %todo dito
   \end{itemize}
   
   Because the stand-alone version of the program has no coupled fluid solver which provides it with pressures/forces at the nodes, these values must be imported via file, too. The structure of such a file is fairly simple: Listing \ref{lst:example_f} shows such an example corresponding to the example mesh of listing \ref{lst:xda}. The first line defines the number $n$ of nodes/vertices the mesh has (in this case $n=4$). The second line holds a floating point number representing a global factor that is multiplied by every force component defined below. A value of $1.0$ has no effect on the load values. Lines three to $n+2$ are the $xyz$-components of the single forces put on the corresponding mesh nodes. The ordering is the same as the vertices in the mesh file. The $xyz$-coordinates must also be represented in the global coordinate system. In the example a load is applied on the first and third node. The first load is directed along the negative z-axis, the second load along the positive y-axis. The other two nodes have no forces applied.
\begin{lstlisting}[caption=Example force file,label=lst:example_f,language=bash,keepspaces=true]
4
1.0
0.0 0.0 -0.65
0.0 0.0 0.0
0.0 2.34 0.0
0.0 0.0 0.0
\end{lstlisting}
   
   
   
  \subsubsection{System setup}
   \begin{itemize}
  	\item setting up libmesh\\
   	- LinearImplicitSystem, erklärung aus doxygen\\
   	- 6 variablen erstellen\\
    - set boundary condition types, DirichletBoundary class\\
	  nochmal auf theorieteil eingehen
   \end{itemize}
   
   
   
  \subsubsection{Matrix and vector assembly}
   \begin{itemize}
    \item material matrices: D\_m und D\_p
    
   	\item creation of local and global stiffness matrix
   	
   	\item integral with gauss-quadrature
   	
   	\item read corresponding entry from force array and set it in the right-hand-side vector

   	\item storing already processed nodes with unordered\_set-structure
   \end{itemize}
   
   
   
  \subsubsection{Solving the system}
   \begin{itemize}
   	\item solving part is just one line. calls the assemble-function and the defined solver (e.g. if PETSc is installed)
   	
   	%\item hier kann man aber schreiben, mit was libmesh umgehen kann an lösern,
    
    \item which settings are possible (error-eps, \#iters)
    
    \item build\_solution\_vector
   \end{itemize}
   
   
   
  \subsubsection{Output}
   - for standalone-version output as exodus2-file\\
   - exodus2 can be read by ParaView, parallel vtk-output is not supported by libMesh
   
   - according to the user command line parameter, output file is written to specified file or not at all
 
 
 
 \subsection{Parallelization with MPI}
 additional steps to make the code ready for multi process execution with MPI\\
  \subsubsection{libMesh requirements}
   grundsätzlich ist zum lösen des gleichungssystem mit mehreren prozessen petsc als externe lib notwendig
  
  \subsubsection{Partitioning the mesh}
   am mesh muss nichts verändert werden, da libmesh automatisch eine partitionierung des meshes vornimmt (kann aber verbessert werden)
   
  \subsubsection{Local elements}
   grundsätzlich sorgt libMesh dafür, dass jeder prozessor nur zugriff auf "seine" element, knoten usw. hat. Das wird hier wichtig mit änderungen an den iteratoren usw.
  
  \subsubsection{Assembly changes}
   damit rhs korrekt gesetzt wird muss über die prozessgrenzen hinweg klar sein, ob knoten bereits bearbeitet wurde oder nicht. wie das gelöst wurde kommt hier rein\newline