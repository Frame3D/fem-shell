\section{FEM Code Implementation}
contains development of the program code with focus on the assembly of the system and its solving, the process of parallelization %TODO
 
 
 
 \subsection{Introduction to libMesh}
 The libMesh finite element library was stared as part of the Ph.D. work of Benjamin Kirk \cite{kirk2007adaptive}. It is a tool for numerical simulation of partial differential equations on serial and parallel platforms and uses the finite element method. Major goals are to provide data structures and algorithms for applications that need implicit numerical methods, parallel computing, adaptive mesh refinement techniques, or, a combination of them. Further, it simplifies many programming details for the user, such as: Reading the mesh from file, initialize data structures, solving the dicretized system, and, writing out the results \cite{kirk2013case}.
 
 LibMesh allows discretization of one, two and three dimensional problems using several geometric element types, including: Edges, quadrilaterals, triangles, tetrahedra, hexahedra, pyramids, prisms and some infinite elements of quadrilaterals or hexahedra. Finite elements include traditional first and second order Lagrange, as well as arbitrary order hierarchical bases, and N\'{e}d\'{e}lec elements of first type.
 
 Mesh partitioning is available in libMesh through interfaces to several external packages, but also some internal partitioning algorithms are provided: Linear and centroid partitioner as examples of internal algorithms, Metis and ParMetis \cite{karypis1998fast} as examples for external partitioner. In addition to these two, libMesh includes interfaces to solver libraries such as PETSc \cite{petsc2015url} and LASPack \cite{laspack2015url}. Thus, libMesh provides several linear equation solvers such as GMRES, CG, Bi-CGSTAB, QMR, and preconditioners like Jacobi, incomplete LU factorization and incomplete Cholesky factorization. The choice of an appropriate solver and preconditioner is made by the user at runtime.
 
 A wide variety of mesh formats are supported by libMesh to facilitate use of complex geometries. The following is an incomplete list of supported input and output formats: Nemesis, TetGen, I-deas Universal UNV, AVS's ASCII UCD, Visualization Toolkit VTK, libMesh formats XDR/XDA, ExodusII, GMSH, LANL's General Mesh Viewer GMV, GnuPlot (only output), Matlab (only input) \cite{kirk2013case}.
 
 An example program using the libMesh library would look like listing \ref{lst1}.
 \begin{lstlisting}[caption=Example libMesh program,label=lst1]
#include "libmesh/libmesh.h"
#include "libmesh/additional_libmesh_components"

using namespace libMesh;

void assemble_something(EquationSystems& es, const std::string& system_name);

int main (int argc, char** argv)
{
	LibMeshInit (int argc, char** argv);
	
	Mesh mesh( init.comm() );
	
	// mesh generation via MeshTools::Generation::build_... or mesh import from file via mesh.read(std::string filename)
	
	EquationSystems es(mesh);
	
	LinearImplicitSystem& system = es.add_system<LinearImplicitSystem> ("example system");
	
	system.add_variable ("a", FIRST);
	system.add_variable ("b", SECOND, LAGRANGE);
	
	system.attach_assemble_function (assemble_something);

	es.init();
	
	system.solve();
	
	VTKIO (mesh).write_equation_systems ("out.pvtu", es);
	
	return 0;
}
 \end{lstlisting}
 In fact, this is the base construction of nearly every libMesh program. It starts with including libMesh components that are needed by the program, e.g. \textit{mesh.h, equation\_systems.h, fe.h}. Then, the library needs to be initialized (line 10). This is necessary because it may depend on a number of other external libraries like MPI and PETSc that require initialization before use. On the other hand, if the \texttt{\textbf{LibMeshInit}} object goes out of scope, the other libraries are finalized automatically by libMesh. Next, a mesh is created (lines 12-14) on the default MPI communicator (even if the program is executed single-threaded). The mesh can either be read from file or created by internal mesh generation tools. In line 16 an equation systems object is created. It can contain multiple different systems. Here, only one linear implicit system is added to the object (line 16). Each system can contain multiple variables of different approximation orders (see lines 20/21). Many systems require a user-defined function that will assemble the (linear) system (lines 6 and 23). Now, the data structures for equation system must be initialized which is done in line 25. The solving of the systems is done in line 27 of the code. This one line of code calls the assemble function defined earlier and invokes the default numerical solver. If the external library PETSc is installed, the solver can be controlled from the command line by the user. After solving the system, the solution can be written to file; here, for example, the results are written to a VTK-formatted plot file (line 29).
 
 \subsection{Implementation Details}
 details about the implementation with the libmesh FEM framework %TODO
 
 
 
  \subsubsection{Initialization}
   \begin{itemize}
   	\item loading of parameters
   	\item setting up libmesh (evtl. uninteressant und es kann weg, oder es muss noch mehr hier rein)
   \end{itemize}
   
   
   
  \subsubsection{Mesh file import}
   \begin{itemize}
   	\item wie sieht mesh file aus
   	\item welche typen werden akzeptiert
   	\item welche ids für bcs müssen verwendet werden
   \end{itemize}
   
   
   
  \subsubsection{System setup}
   \begin{itemize}
   	\item erstellen des linearimplicitsystems
   	\item erstellen der variablen
   	\item der bcs (grundsätzlich auf die beiden bc-typen eingehen, wie das in libmesh gelöst wurde)
   	\item des solvers usw.
   \end{itemize}
   
   
   
  \subsubsection{Matrix and vector assembly}
   \begin{itemize}
   	\item hier wird auf die erstellung der lokalen und globalen stiffnessmatrix eingegangen
   	\item integral mit gauss-quadratur lösen
   	\item das auslesen der forces und der entsprechende eintrag in der rhs gesetzt
   	\item das mitverfolgen der bereits bearbeiteten knoten mittels unordered\_set
   \end{itemize}
   
   
   
  \subsubsection{Solving the system}
   \begin{itemize}
   	\item das lösen an sich ist eine code-zeile
   	\item hier kann man aber schreiben, mit was libmesh umgehen kann an lösern,
    \item welche einstellmöglichkeiten es gibt (error-eps, \#iters).
    \item und es geht drum, wie man an die tatsächlichen werte für die displacements kommt und was daraus am ende wird
   \end{itemize}
   
   
   
  \subsubsection{Output}
   für die standalone-version noch ein absatz zur ausgabe in exodus2/vtk-file
 
 
 
 
 
 \subsection{Parallelization with MPI}
 additional steps to make the code ready for multi process execution with MPI\\
  \subsubsection{libMesh requirements}
   grundsätzlich ist zum lösen des gleichungssystem mit mehreren prozessen petsc als externe lib notwendig
  
  \subsubsection{Partitioning the mesh}
   am mesh muss nichts verändert werden, da libmesh automatisch eine partitionierung des meshes vornimmt (kann aber verbessert werden)
   
  \subsubsection{Local elements}
   grundsätzlich sorgt libMesh dafür, dass jeder prozessor nur zugriff auf "seine" element, knoten usw. hat. Das wird hier wichtig mit änderungen an den iteratoren usw.
  
  \subsubsection{Assembly changes}
   damit rhs korrekt gesetzt wird muss über die prozessgrenzen hinweg klar sein, ob knoten bereits bearbeitet wurde oder nicht. wie das gelöst wurde kommt hier rein\newline