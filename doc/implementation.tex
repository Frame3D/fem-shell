\section{FEM Code Implementation}
 In this chapter the FEM framework ``libMesh'' is presented at first that was used in the development of the program. Then, details on important parts of the implementation like the system's matrix assembly or mesh format requirements for import are illustrated. The parallelization with MPI concludes this chapter, pointing out details about libMesh's requirements for MPI usage and important modifications to the program's code.
 
 
 
 \subsection{Introduction to libMesh}\label{sec:Impl-Intro}
 The libMesh finite element library was started as part of the Ph.D. thesis of Benjamin Kirk \cite{kirk2007adaptive}. It is a tool for numerical simulation of partial differential equations on serial and parallel platforms and uses the finite element method. A major goal is to provide data structures and algorithms for applications that need implicit numerical methods, parallel computing, adaptive mesh refinement techniques, or, a combination of them. Further, it simplifies many programming details for the user such as: Importing mesh structures, providing and initialize data structures for the equation systems, solving the discretized system and writing out the results \cite{kirk2013case}.
 
 LibMesh allows discretization of one, two and three dimensional problems using several geometric element types, including: Edges, rectangles, triangles, tetrahedra, hexahedra, pyramids, prisms and some infinite elements of quadrilaterals or hexahedra. Finite elements include traditional first and second order Lagrange, as well as arbitrary order hierarchical bases, and N\'{e}d\'{e}lec elements of first type.
 
 Mesh partitioning is available in libMesh through interfaces to several external packages, but also some internal partitioning algorithms are provided: Linear and centroid partitioner as examples of internal algorithms, Metis and ParMetis \cite{karypis1998fast} as examples for external libraries. In addition to these two, libMesh includes interfaces to solver libraries such as PETSc \cite{petsc-web-page} and LASPack \cite{laspack2015url}. Thus, libMesh offers several linear equation solvers such as GMRES, CG, Bi-CGSTAB, QMR, and preconditioners like Jacobi, incomplete LU factorization and incomplete Cholesky factorization. The choice of an appropriate solver and preconditioner can be made by the user at runtime or directly coded into the program.
 
 A wide variety of mesh formats are supported by libMesh to facilitate the handling of complex geometries. The following is an incomplete list of supported input and output formats: Nemesis, TetGen, I-deas Universal UNV, AVS's ASCII UCD, Visualization Toolkit VTK, libMesh formats XDR/XDA, ExodusII, GMSH, LANL's General Mesh Viewer GMV, GnuPlot (only output), Matlab (only input) \cite{kirk2013case}.
 
 An example program using the libMesh library would look like Listing \ref{lst:example-libmesh}.
 \begin{lstlisting}[caption=Example libMesh program,label=lst:example-libmesh]
#include "libmesh/libmesh.h"
// include additional libmesh components

using namespace libMesh;

void assemble_something(EquationSystems& es, const std::string& system_name);

int main (int argc, char** argv)
{
	LibMeshInit init(int argc, char** argv);
	
	Mesh mesh( init.comm() );
	
	// mesh generation via MeshTools::Generation::build_... or mesh import from file via mesh.read(std::string filename)
	
	EquationSystems es(mesh);
	
	LinearImplicitSystem& system = es.add_system<LinearImplicitSystem> ("example system");
	
	system.add_variable ("a", FIRST);
	system.add_variable ("b", SECOND, LAGRANGE);
	
	system.attach_assemble_function (assemble_something);

	es.init();
	
	system.solve();
	
	VTKIO (mesh).write_equation_systems ("out.pvtu", es);
	
	return 0;
}
 \end{lstlisting}
 In fact, this is the base construction of a usual libMesh program. It starts with including libMesh (\textit{libmesh.h}) and all its components that are needed by the program, e.g. \textit{mesh.h, equation\_systems.h, fe.h}. Then, the library needs to be initialized (line 10). This is necessary because it may depend on a number of other external applications like MPI or PETSc that require initialization before use. Furthermore, if the \texttt{\textbf{LibMeshInit}} object goes out of scope, the other libraries are finalized automatically by libMesh. Next, a \texttt{\textbf{Mesh}} object is created (lines 12-14) on the default MPI communicator even if the program is executed single-threaded. The mesh can either be read from file or created by internal mesh generation tools. In line 16 an \texttt{\textbf{EquationSystems}} object is created. It can contain multiple different systems and manage them. Here, only one linear implicit system is added to the object (line 16). Any \texttt{\textbf{...System}} object can contain multiple variables of different approximation orders (see lines 20/21). Many systems require a user-defined function that will assemble the (linear) system (lines 6 and 23). Now, the data structures for the equation system must be initialized which is done in line 25. The solving of all or just some of the systems added to the equation systems object is done in line 27 of the code. This single line of code calls the assemble function defined earlier and invokes the default numerical solver. If the external library PETSc is installed, the solver's properties can be controlled from the command line by the user (cf. \ref{sec:Impl-Details-Init}). After solving the system, the solution can be written to file; here, for example, the results are written to a VTK-formatted plot file (line 29).
 
 \subsection{Implementation Details}\label{sec:Impl-Details}
  This section contains details about the program's implementation supported by libMesh. Different parts of the code like the initialization, loading of the mesh or the system's matrix assembly are described. The focus is put on the interaction between the libMesh library and the user's code. Requirements regarding mesh formats and user arguments are pointed out as well.

 
  \subsubsection{Initialization}\label{sec:Impl-Details-Init}
  The program expects a few arguments set by the user through the command line at start. All parameters are independent from libMesh. The ordering of these parameters are not relevant; some are optional. Here is a complete list of all arguments that can be set in the command line:
  \begin{itemize}
  	\item \textbf{-nu}: The Poisson's ratio $\nu$ is required by the material matrices. A value in the range $0.0 < \nu \leq 0.5$ is recommended for most scenarios.
  	\item \textbf{-e}: The elastic modulus or Young's modulus $E$ is also required by the material matrices. Here, a value $E \gg 0$ is recommended.
  	\item \textbf{-t}: The thickness $t$ of the mesh. It is used at both, the material matrices and the strain-displacement matrices and thus a required parameter to be set by the user.
  	\item \textbf{-d}: This argument is mostly used for the debugging process. If set to ``1'' additional messages regarding transformation matrix entries, strain-displacement matrices, force load vectors and other internal mathematic structures are put out on the console. This parameter is optional, as it only gives the user more information in case of detecting errors. Since it slows down the calculation, it should only be set if needed. To turn the messages off, it can simply be left out or set to ``0''.
  	\item \textbf{-mesh}: The mesh file to import. A required parameter, because no default mesh is provided by the program to be used. The relative path to the file (+ extension) must be specified. Allowed file formats are: libMesh format \textit{xda} (ASCII) and \textit{xdr} (binary) as well as GMSH format \textit{msh}. For more details, see the following section.
  	\item \textbf{-out}: The relative path and filename (\textit{without} extension) for the output of the resulting mesh. This parameter is optional. If not set, no output file will be created. The path to the filename must exist, otherwise no file can be created and libMesh will terminate the program with an error message.
  	\item \textbf{-dt}: The constant time step length value. This parameter is only available in the preCICE-version of the program and is explained further in Section \ref{sec:Coupl-Impl-Integration}.
  \end{itemize}
  
  If the external library PETSc is installed and libMesh is configured to use it, the user can set additional optional command line arguments \cite{petsc-user-ref}. In fact, if one uses PETSc, it will look through all parameters to find those it can process by itself. The following list is therefore limited to parameters that directly coincide with the need of this program. For more PETSc command line arguments see \cite{petsc-user-ref}.
  \begin{itemize}
  	\item \textbf{-ksp\_type}: Specifies the Krylov subspace method. Options are: \texttt{richardson}, \texttt{chebyshev}, \texttt{cg}, \texttt{gmres}, \texttt{tcqmr}, \texttt{bcgs}, \texttt{cgs}, \texttt{tfqmr}, \texttt{cr}, \texttt{lsqr}, \texttt{bicg}, \texttt{preonly}.
  	\item \textbf{-pc\_type}: To employ a particular preconditioning method used with the Krylov space method, the user can select one using this argument. Options are: \texttt{none}, \texttt{jacobi}, \texttt{bjacobi}, \texttt{sor}, \texttt{eisenstat}, \texttt{icc}, \texttt{ilu}, \texttt{asm}, \texttt{gasm}, \texttt{gamg}, \texttt{bddc}, \texttt{ksp}, \texttt{composite}, \texttt{lu}, \texttt{cholesky}, \texttt{shell}. 
  \end{itemize}
   
   
   
  \subsubsection{Mesh file import}\label{sec:Impl-Details-MeshFileImport}
   The mesh geometry needs to be defined in a mesh file. LibMesh can import meshes from many different formats, including its own formats XDA and XDR, the first one stored in human-readable ASCII format, the latter one written in binary code. Another one is the GMSH format \textit{msh}. There are other formats libMesh can import, but only the three mentioned are currently supported by the thesis' program. A mesh file must provide the following information such that the program can work with it:
   \begin{itemize}
   	\item A list of vertices. Every vertex must be specified with its $xyz$-coordinates defined in the global coordinate system.
   	\item A list of elements the mesh consists of. The elements are normally defined by their type, for example a three-node triangle or a four-node quadrilateral, and a list of vertex identifiers representing the element's nodes.
   	\item A list of boundary conditions. The program provides two different types of boundary conditions. The type (or ID) has to be specified in form of identifiers on element's nodes or edges. In the latter case the boundary condition is used on both nodes defining the edge.
   \end{itemize}
   Listing \ref{lst:xda} shows a short example of a mesh defined in the xda-format. It displays the unit square with its center at the global origin, composed of two three-node triangles. It has different boundary conditions on the bottom and top edge.
\begin{lstlisting}[caption=Example xda mesh file,label=lst:xda,language=bash,keepspaces=true]
libMesh-0.7.0+
2       # number of elements
4       # number of nodes
.       # boundary condition specification file
n/a     # subdomain id specification file
n/a     # processor id specification file
n/a     # p-level specification file
2       # n_elem at level 0, [ type (n0 ... nN-1) ]
3 0 1 2          # 3 -> triangle with 3 nodes, 0 1 2 -> vertices 0, 1 and 2
3 1 3 2          #                             1 3 2 -> vertices 1, 3 and 2
-1.0 -1.0  0.0   # x y z coordinates of vertex 0
 1.0 -1.0  0.0   #                      vertex 1
-1.0  1.0  0.0   #                      vertex 2
 1.0  1.0  0.0   #                      vertex 3
2                # number of boundary conditions
0 0 1            # 0 -> element 0, 0 -> edge 0 (between vertex 0 and 1), bc-type 1
1 1 0            # 1 -> element 1, 1 -> edge 1 (between vertex 3 and 2), bc-type 0
\end{lstlisting}
   Listing \ref{lst:msh} shows the same example mesh but in the GMSH format. Here, libMesh has some requirements on how the GMSH mesh file has to be structured: Every line defined in the \texttt{\$Elements}-section contains severals numbers, ordered as follows: Element index, element type, number of tags, physical entity number, geometrical entity, additional list of tags, list of node indices \cite{gmsh-manual}. LibMesh requires the number of tags to be at least two. The first tag (physical entity) will be used by libMesh to identify the boundary condition ID; the second tag will be ignored - at least the author could not find where libMesh uses this value. LibMesh also treats the element type in different ways: The highest dimensional element types, for example 2D elements, like triangle and quadrilaterals, will act as the mesh defining elements. Every element that has lower dimension, (e.g. nodes or edges), will be seen as boundary condition definitions by libMesh. See Listing \ref{lst:msh} for clarification: There are six elements defined. Two triangles and four single nodes. The mesh only exists of the two triangles. The four nodes will be used by libMesh to set boundary conditions at the corresponding nodes of the mesh. In this case node 1 and 2 gets boundary conditions with ID 0, node 3 and 4 with ID 1. This behavior of libMesh must be kept in mind when dealing with GMSH mesh files.
\begin{lstlisting}[caption=Example GMSH mesh file,label=lst:msh,language=bash,keepspaces=true]
$MeshFormat
2.2 0 8
$EndMeshFormat
$Nodes
4
1 -1.0 -1.0  0.0
2  1.0 -1.0  0.0
3 -1.0  1.0  0.0
4  1.0  1.0  0.0
$EndNodes
$Elements
6
1 2 2 0 0 1 2 3
2 2 2 0 0 2 4 3
3 15 2 0 0 1
4 15 2 0 0 2
5 15 2 1 0 3
5 15 2 1 0 4
$EndElements
\end{lstlisting}

   The program features two different types of boundary conditions whose identifiers must be set in the mesh file:
   \begin{itemize}
   	\item Simply supported boundaries are of type ``\texttt{0}''. The boundary cannot be moved but is free to rotate and have no moment resistance. In mathematical notation:
   	\begin{equation*}
   	u = v = w = 0, M_x = M_y = 0
   	\end{equation*}
   	\item Clamped boundary has type ``\texttt{1}''. Here, the boundary is completely fixed with no movement and no rotation possible. Mathematically:
   	\begin{equation*}
   	u = v = w = 0, \theta_x = \theta_y = 0
   	\end{equation*}
   \end{itemize}
   In the stand-alone version of the program no coupled fluid solver provides it with pressures/forces and moments at the nodes. Therefore, these values must be imported via file, too. The data is stored in an extra file that requires the following naming convention: For a mesh file named ``mesh.xda'', the corresponding force file must be named ``mesh\_f'' (without any extension). Therefore no additional command line argument is necessary and the force file is independent from the format the mesh file has. The structure of a force file is simple: Listing \ref{lst:example_f} shows an example corresponding to the mesh of Listing \ref{lst:xda}. The first line defines the number $n$ of nodes/vertices the mesh has (in this case $n=4$). The second line holds a floating point number representing a global factor that is multiplied by every force/moment component defined below. A value of $1.0$ has no effect on the load values. Lines 3 to $n+2$ are the $xyz$-components of the single forces put on the corresponding mesh nodes followed by three values for the moments $M_x, M_y, M_z$. The ordering is the same as for the vertices in the mesh file. The $xyz$-coordinates must also be specified in the global coordinate system. In the example a load is applied on the first and third node. The first load is directed along the negative z-axis, the second load along the positive y-axis. The other two nodes have no forces and all nodes have no moments applied.
\begin{lstlisting}[caption=Example force file,label=lst:example_f,language=bash,keepspaces=true]
4
1.0
0.0  0.0  -0.65  0.0  0.0  0.0
0.0  0.0   0.0   0.0  0.0  0.0
0.0  2.34  0.0   0.0  0.0  0.0
0.0  0.0   0.0   0.0  0.0  0.0
\end{lstlisting}
   
   The implementation's code to import a mesh file is rather short (Listing \ref{lst:load_mesh}).
\begin{lstlisting}[caption=Loading mesh and prepare for use,label=lst:load_mesh,keepspaces=true]
Mesh mesh(init.comm(), 2);
mesh.allow_renumbering(false);
mesh.read(in_filename);	
mesh.print_info();
\end{lstlisting}   
   The first line creates a 2D mesh distributed across the default MPI communicator (gathered by the \texttt{LibMeshInit}-object). The mesh is read in line 3 from the file located at the place defined by \texttt{in\_filename}. In line 4 information about the mesh is printed to the console. A special detail is line 2: It is not guaranteed that the ordering of the nodes defined in the mesh file is the same after libMesh has imported the mesh file. Since the program uses the additional force file to apply the loads onto the mesh nodes, this mapping could be destroyed. Therefore the function call in line 2 forbids libMesh to automatically renumber the nodes of the mesh and let the ordering be as defined in the mesh file.


  \subsubsection{System setup}\label{sec:Impl-Details-SystemSetup}
  After libMesh and possible external libraries are initialized and the mesh was created and initialized, too, the equation system must be set up. Listing \ref{lst:setup_system} shows the relevant part of the implementation.
\begin{lstlisting}[caption=Setting up the equation system,label=lst:setup_system,keepspaces=true]
EquationSystems equation_systems (mesh);
LinearImplicitSystem& system = equation_systems.add_system<LinearImplicitSystem> ("Elasticity");

unsigned int u_var  = system.add_variable("u",  FIRST, LAGRANGE);
unsigned int v_var  = system.add_variable("v",  FIRST, LAGRANGE);
unsigned int w_var  = system.add_variable("w",  FIRST, LAGRANGE);
unsigned int tx_var = system.add_variable("tx", FIRST, LAGRANGE);
unsigned int ty_var = system.add_variable("ty", FIRST, LAGRANGE);
unsigned int tz_var = system.add_variable("tz", FIRST, LAGRANGE);

system.attach_assemble_function (assemble_elasticity);

std::set<boundary_id_type> boundary_ids;
boundary_ids.insert(0);
std::vector<unsigned int> variables;
variables.push_back(u_var);
variables.push_back(v_var);
variables.push_back(w_var);
ConstFunction<Number> cf(0.0);
DirichletBoundary dirichlet_bc(boundary_ids, variables, &cf);

boundary_ids.clear();
boundary_ids.insert(1);
variables.push_back(tx_var);
variables.push_back(ty_var);
variables.push_back(tz_var);
DirichletBoundary dirichlet_bc2(boundary_ids, variables, &cf);

system.get_dof_map().add_dirichlet_boundary(dirichlet_bc);
system.get_dof_map().add_dirichlet_boundary(dirichlet_bc2);

equation_systems.init();
equation_systems.print_info();
\end{lstlisting}
   In line 1 an \texttt{\textbf{EquationSystems}}-object is created. It contains and controls all equation systems defined for a mesh, that is passed as parameter in its constructor. It can have multiple systems or just one like in this case. Here, a linear implicit system is to be used. LibMesh offers exactly such a system (\texttt{\textbf{LinearImplicitSystem}}). In line 2 the system is created named ``Elasticity'' and added to the equation systems object. As discussed in Section \ref{sec:Shell-Shell}, the system has six variables, namely: $u, v, w, \theta_x, \theta_y, \theta_z$. These variables are added to the system in line 4 to 9. All of them are of first polynomial order and members of the Lagrange finite element family. The \texttt{add\_variable}-function returns a unique number identifying the variable just added. In order to assemble the system matrix and the right-hand side, a user-defined function must be attached to the system. This is done in line 11. The assemble function will be discussed in Section \ref{sec:Impl-Details-Assembly}. The only part missing is the definition of the different boundary conditions. This is done between the lines 13 and 30. As stated in the previous section, the program features two types of boundary conditions: Simply supported and clamped with the ID ``0'' and ``1'', respectively. Because libMesh allows multiple IDs representing the same boundary condition type, in line 13 a \texttt{set} is created and filled with the 0-ID in the next line. After that, a vector containing the IDs of the system's variables must be created. In the case of a simply supported boundary only the three displacement variables $u,v,w$ are affected (lines 15-18). Before creating the \texttt{\textbf{DirichletBoundary}}-object, a function supplying the Dirichlet value must be defined. In this case the value must be zero at the boundary. A \texttt{ConstFunction} initialized with the value zero is therefore created in line 19. The constructor for the Dirichlet object takes the ID-set, the variables-vector and the value-function as parameters and copies their content into the boundary object. The set and vector will be reused for the second boundary type. Now the 1-ID is inserted in the cleared set in line 23 and the twist variables $\theta_x, \theta_y, \theta_z$ are added to the existing variables in the vector (lines 24ff.). Another \texttt{DirichletBoundary} object is created with the new initialization parameters. Finally, the two boundary types are added to the system in line 29f. When the preparation steps are finished, the system can finally be initialized and information about the system can be printed to the console.
     

   
  \subsubsection{Matrix and vector assembly}\label{sec:Impl-Details-Assembly}
  As stated in Section \ref{sec:Impl-Intro}, libMesh tries to do as many programming tasks as possible on its own and let the user concentrate on the mathematical/physical problems to model. The last sections showed that this is often true, since the user often only need to set parameters, create predefined objects or call libMesh functions. To solve the system, libMesh calls a user-defined assembly function. This function is the part where the user gets involved at most, because here the system matrix and the right-hand side (RHS) must be assembled. Nevertheless, libMesh helps the user with many auxiliary function as can be seen further down. The main part of the assembly function is described in Listing \ref{lst:assemble}.
\begin{lstlisting}[caption=Assemble System Matrix and RHS,label=lst:assemble,float]
LinearImplicitSystem& system = es.get_system<LinearImplicitSystem>("Elasticity");
const DofMap& dof_map = system.get_dof_map();

DenseMatrix<Number> Ke, Ke_m, Ke_p;
DenseVector<Number> Fe;
DenseMatrix<Real> trafo;
DenseMatrix<Real> transUV;
DenseMatrix<Real> dphi;
Real area = 0.0;

std::vector<dof_id_type> dof_indices;
std::unordered_set<dof_id_type> processedNodes;
processedNodes.reserve(mesh.n_local_nodes());

MeshBase::const_element_iterator       el     = mesh.active_local_elements_begin();
const MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();
for (; el != end_el; ++el)
{
	const Elem* elem = *el;
	dof_map.dof_indices (elem, dof_indices);
	ElemType type = elem->type();

	initElement(&elem, transUV, trafo, dphi, &area);

	calcPlane(type, transUV, dphi, &area, Ke_m);
	calcPlate(type, dphi, &area, Ke_p);
	constructStiffnessMatrix(type, Ke_m, Ke_p, Ke);
	localToGlobalTrafo(type, trafo, Ke);
	contribRHS(&elem, Fe, &processedNodes);

	dof_map.constrain_element_matrix_and_vector(Ke, Fe, dof_indices);

	system.matrix->add_matrix (Ke, dof_indices);
	system.rhs->add_vector    (Fe, dof_indices);
}
\end{lstlisting}
   The first step is to get a reference to the system whose matrix and vector needs to be assembled. In this case the ``Elasticity'' system is used (line 1). Next, a reference to a special object is retrieved from the system: The \texttt{\textbf{DofMap}}-object handles the numbering of degrees of freedom on a mesh and manages the mapping of the local matrices to the right positions in the overall system matrix. In line 3 to 9 several variables are defined: \texttt{Ke}, \texttt{Ke\_m} and \texttt{Ke\_p} are matrices representing the shell element's stiffness matrix, plane (or \textbf{m}embrane) stiffness matrix part and \textbf{p}late stiffness matrix part. The values of the element's RHS are stored in the vector \texttt{Fe}. The other three matrices are needed for the transformation of the element to local coordinates (\texttt{trafo}), the storage of the transformed nodes (\texttt{transUV}) and the partial derivatives (\texttt{dphi}). The element's area is stored in the variable of the same name.

   The assembly function creates the local stiffness matrix and RHS for every single finite element and adds it to the global system matrix and system right-hand side. Therefore, one has to iterate over all the mesh elements. This is done in line 15 to 35. The following steps are made in the exact same order:
   \begin{itemize}
   	\item Get the mapping of the element's degrees of freedom to their positions in the system matrix (line 20).
   	\item Transform the element from global to local coordinates, calculate its partial derivatives and its area (line 23).
   	\item Assemble the plane and plate stiffness matrix part of the shell element (line 25 + 26) and the construction of the shell stiffness matrix for the current element (line 27).
   	\item Transform the local shell stiffness matrix back to global coordinates (line 28).
   	\item Apply possible forces to the element in form of contributing to the local RHS (line 29).
   	\item Constrain the local element's stiffness matrix and RHS according to the set boundary conditions (line 31): LibMesh provides a function that automatically constrains the system matrix and right-hand side vector due to the boundary condition definitions in the initialization step.
    \item Add the element's stiffness matrix to the global system matrix (line 33): The final element's stiffness matrix is added to the overall system matrix through the function provided by libMesh. The vector storing the mappings of the degrees of freedom ensures that the matrix is added at the correct position in the system matrix.
    \item Add the element's RHS to the global RHS (line 34): Same as before but now for the right-hand side vector.
   \end{itemize}
   In the following, some of the steps stated above are discussed in more detail, namely the coordinate transformation, the construction of the shell element stiffness matrix and the contribution to the right-hand side vector.
   
   The transformation from global to local coordinates is described in Section \ref{sec:Shell-CoTrafo}. Let $\tilde{A} = \begin{pmatrix}
   x_1=0 & y_1=0
   \end{pmatrix}^T, \tilde{B} = \begin{pmatrix}
   x_2 & y_2=0
   \end{pmatrix}^T, \tilde{C} = \begin{pmatrix}
   x_3 & y_3
   \end{pmatrix}$ be the nodes of a transformed triangular element. Then the partial derivatives are as follows:
   \begin{align*}
   x_{12} = x_1 - x_2 = -x_2 &\qquad y_{12} = y_1 - y_2 = 0\\
   x_{31} = x_3 - x_1 = x_3  &\qquad y_{31} = y_3 - y_1 = y_3\\
   x_{23} = x_2 - x_3        &\qquad y_{23} = y_2 - y_3 = -y_3
   \end{align*}
   For a transformed quadrilateral the derivatives are straightforward: $x_{ij} = x_i - x_j, y_{ij} = y_i - y_j$, because no implicit positions can be assumed for the transformed nodes.
   
   The area of a triangle can easily be calculated during the creation of the transformation matrix. The cross product between the spanning vectors $\vec{u}$ and $\vec{v}$ (cf. Section \ref{sec:Shell-CoTrafo}) is 2 times the area of the triangle. Thus, the area is:
   \begin{equation*}
   A_\triangle = \frac{1}{2} \left|\vec{u} \times \vec{v}\right|
   \end{equation*}
   For the quadrilateral area $A_\square$ one can use the Gauss' area formula:
   \begin{equation*}
   A_\square = \frac{1}{2} \sum_{i=1}^{4} \left|\begin{pmatrix}
   x_i & x_{(i+1)\%4}\\
   y_i & y_{(i+1)\%4}
   \end{pmatrix}\right|
   \end{equation*}
   where ``\%'' denotes the modulo-operator.
   
   After the assembly of the plane stiffness part described in Section \ref{sec:Shell-Plane-Tri} for triangular elements and in \ref{sec:Shell-Plane-Quad} for quadrilateral elements, a matrix $K_m$ with $2n\!\times\! 2n$ entries results, $n$ being the number of nodes the element has:
   \begin{equation*}
   K_m = \begin{gmatrix}[p]
   m_{1,1} & m_{1,2} & m_{1,3} & \cdots & m_{1,n-1} & m_{1,n} \\
   m_{2,1} & m_{2,2} & m_{2,3} & \cdots & m_{2,n-1} & m_{2,n} \\
   m_{3,1} & m_{3,2} & m_{3,3} & \cdots & m_{3,n-1} & m_{3,n} \\
   \vdots & \vdots & \vdots & \ddots & \cdots   & \vdots \\
   m_{n-1,1} & m_{n-1,2} & m_{n-1,3} & \cdots & m_{n-1,n-1} & m_{n-1,n} \\
   m_{n,1} & m_{n,2} & m_{n,3} & \cdots & m_{n,n-1} & m_{n,n}
   \colops
   \mult{0}{u_1}
   \mult{1}{v_1}
   \mult{2}{u_2}
   \mult{3}{\cdots}
   \mult{4}{u_n}
   \mult{5}{v_n}
   \rowops
   \mult{0}{u_1}
   \mult{1}{v_1}
   \mult{2}{u_2}
   \mult{3}{\vdots}
   \mult{4}{u_n}
   \mult{5}{v_n}
   \end{gmatrix}
   \end{equation*}
   The same holds for the plate stiffness part described in Sections \ref{sec:Shell-Plate-Tri} and \ref{sec:Shell-Plate-Quad}. Here, the matrix has $3n\!\times\! 3n$ entries, $n$ also the number of elements nodes:
   \begin{equation*}
   K_p = \begin{gmatrix}[p]
   p_{1,1} & p_{1,2} & p_{1,3} & p_{1,4} & \cdots & p_{1,n-1} & p_{1,n} \\
   p_{2,1} & p_{2,2} & p_{2,3} & p_{2,4} & \cdots & p_{2,n-1} & p_{2,n} \\
   p_{3,1} & p_{3,2} & p_{3,3} & p_{3,4} & \cdots & p_{3,n-1} & p_{3,n} \\
   p_{4,1} & p_{4,2} & p_{4,3} & p_{4,4} & \cdots & p_{4,n-1} & p_{4,n} \\
   \vdots  & \vdots  & \vdots  & \vdots  & \ddots & \cdots    & \vdots \\
   p_{n-1,1} & p_{n-1,2} & p_{n-1,3} & p_{n-1,4} & \cdots & p_{n-1,n-1} & p_{n-1,n} \\
   p_{n,1} & p_{n,2} & p_{n,3} & p_{n-1,4} & \cdots & p_{n,n-1} & p_{n,n}
   \colops
   \mult{0}{w_1}
   \mult{1}{\theta_{x_1}}
   \mult{2}{\theta_{y_1}}
   \mult{3}{w_2}
   \mult{4}{\cdots}
   \mult{5}{\theta_{x_n}}
   \mult{6}{\theta_{y_n}}
   \rowops
   \mult{0}{w_1}
   \mult{1}{\theta_{x_1}}
   \mult{2}{\theta_{y_1}}
   \mult{3}{w_2}
   \mult{4}{\vdots}
   \mult{5}{\theta_{x_n}}
   \mult{6}{\theta_{y_n}}
   \end{gmatrix}
   \end{equation*}
   
   In Section \ref{sec:Shell-Shell}, it is described that the two stiffness matrices from plane and plate can be superimposed to the shell element's stiffness matrix. This results in a matrix $K$ that consists of $n\!\times\! n$ submatrices ($6n\!\times\! 6n$ entries per submatrix):
   \begin{equation*}
   K = \begin{pmatrix}
   K_{11} & K_{12} & \cdots & K_{1n}\\
   K_{21} & K_{22} & \cdots & K_{2n}\\
   \vdots & \vdots & \ddots & \vdots\\
   K_{n1} & K_{n2} & \cdots & K_{nn}
   \end{pmatrix}
   \end{equation*}
   Every submatrix describes the stiffness for one node of the shell element, i.e.:
   \begin{equation*}
   K_{ij} = \begin{pmatrix}
   m_{2i,2j}   & m_{2i,2j+1}   & 0           & 0             & 0             & 0\\
   m_{2i+1,2j} & m_{2i+1,2j+1} & 0           & 0             & 0             & 0\\
   0           & 0             & p_{3i,3j}   & p_{3i,3j+1}   & p_{3i,3j+2}   & 0\\
   0           & 0             & p_{3i+1,3j} & p_{3i+1,3j+1} & p_{3i+1,3j+2} & 0\\
   0           & 0             & p_{3i+2,3j} & p_{3i+2,3j+1} & p_{3i+2,3j+2} & 0\\
   0           & 0             & 0           & 0             & 0             & d_{ij}
   \end{pmatrix}
   \end{equation*}
   where $d_{ij}$ is a thousandth of the maximum of the diagonal entries of $K_{ij}$ (cf. Section \ref{sec:Shell-Shell}):
   \begin{equation*}
   d_{ij} = \frac{1}{1000}\max \left\lbrace m_{2i,2j}, m_{2i+1,2j+1}, p_{3i,3j}, p_{3i+1,3j+1}, p_{3i+2,3j+2} \right\rbrace 
   \end{equation*}
   After this step, the local stiffness matrix for the shell element is finally constructed. Before it can be added to the overall system stiffness matrix, it must be transformed back to the global coordinate system as discussed in Section \ref{sec:Shell-CoTrafo}.
   For this purpose let $\tilde{T}$ be the $6\!\times\! 6$ transformation matrix from equation \eqref{eq:trafoTtilde}. Now, every submatrix $K_{ij}$ from $K$ must be transformed in the following way (Eq. \eqref{eq:Kij=Tt Kij T}):
   \begin{equation*}
   \bar{K}_{ij} = \tilde{T}^T K_{ij} \tilde{T}
   \end{equation*}
   for $1 \leq i,j \leq n$.\\
   The resulting global coordinate matrix $\bar{K}_{ij}$ has the same structure as its local ancestor. In order to add it to the system matrix, one has to modify its structure. Until now, the ordering of columns and rows were as follows: All variables for node 1, followed by all variables for node 2, etc. ($u_1, v_1, w_1, \ldots, \theta_{y_n}, \theta_{z_n}$). LibMesh requires the system matrix to be in another format: The first variable for all nodes, then the second variable for all nodes, etc. ($u_1, u_2, \ldots, u_n, v_1, v_2, \ldots, \theta_{z_n}$). This change in format is achieved by the following code (Listing \ref{lst:formatChange}):
\begin{lstlisting}[caption=Bring stiffness matrix into libMesh conform format,label=lst:formatChange,mathescape,numbers=none]
for ($\alpha$ = 0..5)
	for ($\beta$ = 0..5)
		for (i = 0..n-1)
			for (j = 0..j-1)
				$K_{libmesh}(\alpha$n+i,$\beta$n+j$) = \bar{K}($6i+$\alpha$,6j+$\beta)$;
\end{lstlisting}

  The right-hand side of the shell element is constructed in the function described in Listing \ref{lst:contribRHS}.
\begin{lstlisting}[caption=Contribute RHS function,label=lst:contribRHS]
void contribRHS(const Elem **elem, DenseVector<Real> &Fe, std::unordered_set<unsigned int> *processedNodes)
{
	unsigned int nsides = (*elem)->n_sides();
	Fe.resize(6*nsides);
	
	DenseVector<Real> arg;
	for (unsigned int side = 0; side < nsides; side++)
	{
		Node* node = (*elem)->get_node(side);
		dof_id_type id = node->id();
		
		if (processedNodes->find(id) == processedNodes->end())
		{
			processedNodes->insert(id);
			arg = forces[id];			
			Fe(side)          = arg(0);
			Fe(side+nsides)   = arg(1);
			Fe(side+nsides*2) = arg(2);
		}
	}
}
\end{lstlisting}
   The local vector storing the forces and moments has $6n$ entries: Three forces and three moments for each of the $n$ nodes ($n=3$ for the triangular element, $n=4$ for the quadrilateral). The values are stored in a global vector that was filled at the beginning of the program with the entries of the force file. At first (line 3 and 4) the number of sides of the element is get (equals the number of element's nodes $n$) and the RHS-vector is resized accordingly. Then, one has to iterate over the sides/nodes of the element. Here, a problem occurs due to the iteration of the assembly function over all mesh elements: The majority of mesh nodes belongs to more than one element. In order to keep the global RHS data consistent such a node must be processed only once. In Listing \ref{lst:assemble} in line 12 an \texttt{unordered\_set} structure was created. This set keeps record of the IDs of already processed nodes. In line 12 of the RHS contribution function it is checked if the current element node's ID is already existing in that set. If so, the node is skipped and the function continues with the next one. If not, that node's ID is inserted into the set and the corresponding force/moment entries from the global vector is written to the local RHS-vector.



   
   
  \subsubsection{Solving the system}\label{sec:Impl-Details-Solving}
  The system's solving is done in libMesh with only one call:
  \texttt{equation\_systems.\,\!solve()}. This function performs two actions: It calls the user-defined assembly function that constructs the system matrix and right-hand side and after that it starts the solver. The rest is handled by libMesh or libraries like PETSc, respectively, though the user has some options to control the solver's behavior. Listing \ref{lst:solve_system} shows the code section responsible for the system's solving.
\begin{lstlisting}[caption=Solve the system and build solution,label=lst:solve_system,keepspaces=true]
// optionally set solver parameters:
const unsigned int max_iter  = equation_systems.parameters.get<unsigned int>("linear solver maximum iterations");
const Real         tolerance = equation_systems.parameters.get<Real>("linear solver tolerance");
equation_systems.parameters.set<unsigned int>("linear solver maximum iterations")= max_iter;
equation_systems.parameters.set<Real>        ("linear solver tolerance")        = tolerance;

equation_systems.solve();

std::vector<Number> sols;
equation_systems.build_solution_vector(sols);

MeshBase::const_node_iterator no = mesh.nodes_begin();
const MeshBase::const_node_iterator end_no = mesh.nodes_end();
for (; no != end_no; ++no)
{
	Node *nd = *no;
	int id = nd->id();
	Real displ_x = sols[6*id];
	Real displ_y = sols[6*id+1];
	Real displ_z = sols[6*id+2];
	(*nd)(0) += displ_x;
	(*nd)(1) += displ_y;
	(*nd)(2) += displ_z;
}
\end{lstlisting}
   In line 7 the addressed solve-function is called. Before, one can modify the maximum number of iterations the solver will do and the residual's tolerance signaling when the solver should stop. In this case nothing is changed, since the original parameter values are set. It was added to the source code to show the syntax and mention the possibility, but was not used in the program. The equation systems object stores the calculated solution internally. In order to get access to the results, one has to build a vector (line 9f.) where the solutions can be stored in. LibMesh resizes the vector automatically and fills it with the solution values. The order hereby is as follows: First all six values for the d.o.f. for the first node in the order of adding them to the system, then all six values for the second node and so on, i.e. $\overrightarrow{sols} = \begin{pmatrix}
   u_1 & v_1 & w_1 & \theta_{x_1} & \theta_{y_1} & \theta_{z_1} & u_2 & \ldots & \theta_{z_n}
   \end{pmatrix}$ for a mesh with $n$ nodes. The nodes are ordered as defined in the mesh file. Until this position in the code, only the displacements and twists are calculated. What is left is to apply the displacements to the mesh. This is done between line 12 and 24. One has to iterate over all mesh nodes. LibMesh provides a special iterator-type for nodes to do this. The current node's ID is stored in a variable in line 17 and then the displacements for the x-, y- and z-direction is get from the vector. Note, that the values are represented in global coordinates like the coordinates of the nodes in the mesh object. Hence, no transformation is necessary. The single direction displacements are then added to the existing absolute values of the mesh nodes.

   
   
   
  \subsubsection{Output}\label{sec:Impl-Details-Output}
   When the system is solved and the results are applied to the mesh, the program can write the displaced mesh with its additional data to a file. Listing \ref{lst:output} shows the relevant function. First, the function checks if the user does wish any output to be made. If so, an output stream is created with the filename specified by the user as command line argument plus the ExodusII extension ``.e''. Finally, the mesh with all additional data (for example the relative displacements) is written to the specified file.
\begin{lstlisting}[caption=Store results in mesh file,label=lst:output,keepspaces=true]
void writeOutput(Mesh &mesh, EquationSystems &es)
{
	if (!isOutfileSet)
		return;
	
	std::ostringstream file_name;
	file_name << out_filename << ".e";	
	ExodusII_IO (mesh).write_equation_systems(file_name.str(), es);
}  
\end{lstlisting}
   The ExodusII-format was chosen as output format. First, libMesh can handle parallel output for this format on multiple processes. An additional data gathering step is therefore not needed. Additionally, the ExodusII format can be opened and analyzed by ParaView - an open source multiple-platform application for interactive, scientific visualization - which gives the user more flexibility for post-processing work and analysis. It would be possible to use VTK as output format. Here, every process in parallel execution will write the mesh partition it owns in a separate file. This can lead to difficulties in post-processing analysis of the results.
    
 
 
 \subsection{Parallelization with MPI}\label{sec:Impl-Parallel}
  When the complexity of the mesh gets larger or the program is coupled with other solvers and is executed multiple times per time step, it is important to parallelize the computations in order to solve the system in shorter time. The parallelization process with MPI has three major parts: The library itself, the partition of the mesh and the solving of the system. In the following sections these parts are described in more detail. Additionally, it will be stated what code changes had to be performed in order to make the program code working with MPI.
 
 
  \subsubsection{libMesh build time requirements}\label{sec:Impl-Parallel-Requirements}
   Although MPI is used internally throughout the libMesh library as soon as the program runs in MPI-mode, not everything will work as expected. If one tries to run a theoretically fully MPI-compatible libMesh program and tries to solve a system like the linear implicit system in this case, wrong solutions will result. The problem occurs, when libMesh is built and configured without PETSc support. Then, libMesh will use an Eigen sparse solver \cite{eigen-url}; either a version installed in the user's environment or a built-in version from libMesh itself. These solvers are only serial and cannot be used with MPI, referring to an answer on the libMesh-mailing list from Dr.\ John Peterson, one of the libMesh developers. The solution would be to install PETSc and build libMesh against it. The usage of PETSc when libMesh is executed in parallel is a strong recommendation from the developers of libMesh \cite{libmeshMailList}.
 
 
 
  \subsubsection{Partitioning the mesh}\label{sec:Impl-Parallel-Partitioning}
   The parallelization of the solving step is directly linked to the partitioning of the mesh. Every process gets a part of the mesh and solves the system on its partition. LibMesh provides different partitioning algorithms the user can choose from, namely:
   \begin{itemize}
   	\item \texttt{LinearPartitioner}: The linear partitioning algorithm is the simplest of all available partitioners. It takes the element list and splits it into equally-sized parts and assigns them to each processor.
   	\item \texttt{CentroidPartitioner}: The centroid partitioner partitions simply based on the locations of element centroids. It must be defined how to sort the element centroids, i.e. the distance in the x, y or z-direction or the radial distance.
   	\item \texttt{MetisPartitioner}: This partitioner uses the METIS graph partitioner to partition the elements. This partitioner will be used by libMesh at default if no other partitioner is specified.
   	\item \texttt{ParmetisPartitioner}: Here, the ParMETIS graph partitioner will be used to partition the elements. ParMETIS is an MPI-based parallel library and extends the functionality provided by METIS.
   	\item \texttt{HilbertSFCPartitioner}: The Hilbert SFC partitioner uses a Hilbert space filling curve to partition the elements.
   	\item \texttt{MortonSFCPartitioner}: Same as before but with a Morton space filling curve to partition the elements.
   \end{itemize}
   It is easy to use any of these partitioners in code. Listing \ref{lst:partitioners} shows an example of the ParMETIS partitioner. Instead of this partitioner, every other listed class can be placed at line 7 with the corresponding header file included (line 1).
\begin{lstlisting}[caption=Mesh partitioning example,label=lst:partitioners,keepspaces=true]
#include "libmesh/partmetis_partitionier.h"
// (...)
Mesh mesh(init.comm(), 2);
mesh.allow_renumbering(false);
mesh.read(in_filename);	

ParmetisPartitioner partitioner;
partitioner.partition(mesh);
// (...)
\end{lstlisting}
  
  
  \subsubsection{Local elements}\label{sec:Impl-Parallel-Local}
   LibMesh uses a collection of different iterator-types to go through the mesh elements and nodes. This collection can be split into two groups: Local and global iterators. In the serial case there is no difference between the two, since all elements and nodes exist on the same process. If the program is run with multiple processes on a partitioned mesh, it gets important to use local iterators. Thus, the single processes only iterate over their ``own'' elements and nodes without risking to interfere with the neighboring processes. This behavior gets especially important in the assembly function (cf. Section \ref{sec:Impl-Details-Assembly}). Listing \ref{lst:local-elements} shows a short code part of this function. Here, the for-loop header is shown that will iterate over the mesh elements in order to assemble the element's stiffness matrix and right-hand side and add them to the global system matrix and right-hand side, respectively. Note that it will be iterated over \texttt{active\_local\_elements}. In the serial case it is also possible to use \texttt{active\_elements}, which allows iterating over all mesh elements. ``active'' in this case means, that only non-deactivated elements from the mesh will be processed. Since the deactivation of mesh parts is not used in this implementation, one can ignore this term.
\begin{lstlisting}[caption=Local elements iterator,label=lst:local-elements,keepspaces=true]
// (...)
MeshBase::const_element_iterator       el     = mesh.active_local_elements_begin();
const MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();
for (; el != end_el; ++el)
{
	// (...)
}
\end{lstlisting}
   An example where global iterators are still possible and useful is after the solving step (see Section \ref{sec:Impl-Details-Solving}. Listing \ref{lst:global-elements} shows parts of the code after the system gets solved.
\begin{lstlisting}[caption=Global nodes iterator,label=lst:global-elements,keepspaces=true]
// (...)
std::vector<Number> sols;
equation_systems.build_solution_vector(sols);

if (global_processor_id() == 0)
{
	MeshBase::const_node_iterator           no = mesh.nodes_begin();
	const MeshBase::const_node_iterator end_no = mesh.nodes_end();
	for (; no != end_no; ++no)
	{
		// (...)
	}
	// (...)
}
// (...)
\end{lstlisting}
   LibMesh produces the solution vector only on the master process which has ID 0 per definition. Even when running the program with multiple processes, the solution vector on process 0 contains the values for \textbf{all} mesh nodes. Every other process does not have access to the solution vector. In order to apply the displacements onto the mesh nodes, process 0 must iterate over all mesh nodes. Instead of \texttt{local\_nodes}, in line 7 and 8 \texttt{nodes} is used which represents all the nodes of the mesh.
  
  
  
  \subsubsection{Assembly changes}\label{sec:Impl-Parallel-Assembly}
   In Section \ref{sec:Impl-Details-Assembly} it was stated that a problem occurs at the creation of the local right-hand side's vector: Since nodes can be part of multiple elements, they can be processed multiple times and contribute more than one time to the RHS. This was prevented by creating an \texttt{unordered\_set} that stores the ID of already processed nodes. In the serial case this solves the problem. In case of parallel execution, every process generates such a set for itself without knowing what the other processes have already stored in theirs. This way, it cannot be decided if a node that is situated on the boundary between two mesh partitions was already processed by one of these processes. One solution would be to communicate the processed node IDs between the processes such that the information is consistent throughout the mesh. But that would produce a lot of communication overhead and would slow down the program down. With the help of libMesh this problem can be solved without any inter-process communication at all. Listing \ref{lst:rhs-mpi} contains extracts from the assembly function and the auxiliary function to create the local right-hand side.
\begin{lstlisting}[caption=Process local nodes only,label=lst:rhs-mpi,keepspaces=true]
// in the assemble_elasticity function:
std::unordered_set<dof_id_type> processedNodes;
processedNodes.reserve(mesh.n_local_nodes());

//-------------------------------------------------------------------

// in the contribRHS function:
Node* node = (*elem)->get_node(side);
int   id   = node->id();

if (node->processor_id() != global_processor_id())
	continue;
	
if (processedNodes->find(id) == processedNodes->end())
{
	processedNodes->insert(id);
	// (...)
}
// (...)
\end{lstlisting}
   Here, one can see in line 3 that every process will create a set with a size reserved to the number of local elements that process has access to. When the mesh file is imported, LibMesh stores the ID of the process in all nodes that are part of the partition assigned to that process. This is exploited in line 11: If the stored ID of the node does not match the process' ID than it will be continued with the next node of the element. This can only be the case for nodes situated on the partition's boundary with another partition neighboring. If the node does not belong to the calling process, it must belong to the neighboring process. It is impossible to skip a node, since all nodes belong to at least one process. With this line of code, one can ensure that a node is processed only once: If it is not owned by the calling process, it is not processed at all. Otherwise it will be processed once and than marked in line 16 such that the same process will not use it in the future.